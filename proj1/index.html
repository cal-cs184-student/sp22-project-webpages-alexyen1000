<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">@import url('https://themes.googleusercontent.com/fonts/css?kit=-ou4pOz2rBQXdlj5C-P57A');ol{margin:0;padding:0}table td,table th{padding:0}.c9{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:center;height:11pt}.c1{padding-top:12pt;padding-bottom:12pt;line-height:1.15;orphans:2;widows:2;text-align:left;height:11pt}.c8{color:#666699;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:13pt;font-family:"Arial";font-style:normal}.c3{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c0{padding-top:0pt;padding-bottom:10pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c18{padding-top:24pt;padding-bottom:6pt;line-height:1.0;orphans:2;widows:2;text-align:center}.c11{padding-top:12pt;padding-bottom:12pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c7{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c15{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:center}.c20{padding-top:12pt;padding-bottom:2pt;line-height:1.15;orphans:2;widows:2;text-align:center}.c13{padding-top:12pt;padding-bottom:12pt;line-height:1.15;orphans:2;widows:2;text-align:center}.c6{font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c19{font-weight:400;text-decoration:none;vertical-align:baseline;font-size:23pt;font-family:"Ubuntu";font-style:normal}.c2{padding-top:14pt;padding-bottom:4pt;line-height:1.15;orphans:2;widows:2;text-align:center}.c17{text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c5{background-color:#ffffff;max-width:580.5pt;padding:72pt 18pt 72pt 13.5pt}.c16{height:14pt}.c12{height:11pt}.c10{font-weight:700}.c4{color:#808080}.c14{color:#333333}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c5"><h1 class="c18" id="h.fygmoyw3gz35"><span class="c4 c19">CS 184: Sp2022</span></h1><h4 class="c20" id="h.5x1meu3ju9jf"><span class="c6 c4">Alex Yen | Gabriel Khouri-Haddad</span></h4><h3 class="c2" id="h.ac27z3vsna0v"><span class="c8">Overview</span></h3><p class="c11"><span class="c6 c4">This project took us through the basics and challenges of rasterization: drawing triangles, implementing antialiasing by supersampling, implementing transforms, leveraging barycentric coordinates, performing pixel sampling for texture mapping, and finally, using mipmaps for efficient texture antialiasing. What was especially interesting was seeing the various image quality improvements come at the costs of increasing computational complexity and memory. For instance, supersampling takes a lot more memory, but produces very high quality images. Throughout the project, we constantly encountered rounding and floating point errors. It introduced us to the high level of detail required to correctly sample pixels and textures. </span></p><p class="c1"><span class="c6 c4"></span></p><hr><p class="c1"><span class="c6 c4"></span></p><p class="c1"><span class="c6 c4"></span></p><h3 class="c2" id="h.28gc17keqxt8"><span class="c8">Task 1: Drawing Single-Color Triangles</span></h3><p class="c11"><span class="c6 c4">To rasterize a triangle, we first must define a bounding box, which is the smallest box that can encompass a given triangle. This is found by finding the leftmost, topmost, bottommost, and rightmost coordinates of the given 6 points. This allows us to start a nested for loop that starts from the top left of a bounding box and goes into the bottom left, iterating through all the points in the box.</span></p><p class="c11"><span class="c6 c4">Now, we had to check if the center of a point (which is calculated by simply adding 0.5 to the point) was within the bounds of the provided triangle. To do this, we created an inside() helper function, which takes in an (x, y) coordinate, as well as the 6 x/y values of the triangle, and then calculates if the point is inside the triangle using the three line test. In this case, we returned a true value if the result was &gt;= 0, so this includes edge cases.</span></p><p class="c11"><span class="c6 c4">There&#39;s a slight caveat to this. The winding order of the triangle, that is the rotational direction the points are provided in, affects the results of the inside function. We had to first check the rotation of the triangle before passing in any values, and swap two of the coordinates to flip the winding order.</span></p><p class="c11"><span class="c6 c4">Once we know a point is inside the triangle, we can call the provided rasterize_point() function to fill in the sample buffer at that pixel with the provided color. Running on test4.svg gives us the following result:</span></p><p class="c13"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 444.50px; height: 322.00px;"><img alt="" src="images/image12.png" style="width: 453.01px; height: 352.99px; margin-left: -4.01px; margin-top: -16.25px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 365.50px; height: 26.99px;"><img alt="" src="images/image20.png" style="width: 365.50px; height: 26.99px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c11"><span class="c4">This algorithm is one that checks every sample within the bounding box of a triangle. However, we added a speed up to the algorithm.</span><span class="c4 c10">&nbsp;</span><span class="c6 c4">This was done by only checking if every other pixel was inside of the triangle as we iterate over the x positions. As such, we would only be checking half as many times in most cases. Once we know we&rsquo;re firmly inside the triangle, we can simply add the pixel from the x position before the current one into the triangle without checking. The only extra thing to account for was literal edge cases, in which we either enter or leave the triangle. Once we enter the triangle and once we leave it, we check if the x-position before the current needs to be filled in as well. </span></p><p class="c11"><span class="c6 c4">In addition to this, we also added some more basic speedups, like parallelizing the for loops and exiting the inside function early if a negative value was encountered. The below tests compare our sped up times on the cube against default times.</span></p><p class="c13"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 511.94px; height: 285.07px;"><img alt="" src="images/image16.png" style="width: 511.94px; height: 285.07px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><h3 class="c2" id="h.z35prlusp4oe"><span class="c8">Task 2: Antialiasing by Supersampling</span></h3><p class="c0"><span class="c6 c4">Supersampling is a relatively simple algorithm that can antialias a triangle. This is done by essentially getting a more detailed look at a given pixel, dependent on the sample rate. Instead of a boolean true or false per pixel, we can now compute the average of the subpixels, allowing us to create a gradient, a smoother transition between triangle colors.</span></p><p class="c0"><span class="c6 c4">Adding antialiasing by supersampling required a simple modification to the current rasterizer function. We added an additional two nested for loops which would loop through all the subpixels of a given coordinate, as determined by the sample rate. The range of these for loops would be determined by the square root of the sample rate, thus creating a square containing a number of subpixels equal to the sample rate.</span></p><p class="c0"><span class="c6 c4">To find each subpixel, we would take the (x, y) coordinate of the current pixel, and add the corresponding i and j values from the added nested for loops divided by the size of the subpixel, as well as adding 0.5 / size to the position to reach the center of the subpixel.</span></p><p class="c0"><span class="c6 c4">From there, we could pass in the subpixel location to the inside triangle checker, and if it is, then store the color in the sample buffer (indexed to accommodate for the subpixels using the sample rate and the i and j values). One thing we had to do was increase the size of the sample buffer when the sample rate was increased, which was done by adding a line that did this in the clear_buffer() function.</span></p><p class="c0"><span class="c6 c4">Finally, when it came to resolving to the framebuffer, we had to average the colors out for all the subpixels in a given pixel. We added a for loop to that function which simply used the sample rate as a range to iterate through the given pixel in the sample buffer, adding whatever color it encountered to the sum. This total was divided by the sample rate to find the average color, which then goes on to be the color of the pixel.</span></p><p class="c7 c12"><span class="c6 c4"></span></p><h3 class="c2" id="h.oww9de451g49"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 376.21px; height: 281.91px;"><img alt="" src="images/image33.png" style="width: 376.21px; height: 281.91px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 379.83px; height: 283.09px;"><img alt="" src="images/image1.png" style="width: 379.83px; height: 283.09px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 237.50px; height: 37.64px;"><img alt="" src="images/image21.png" style="width: 237.50px; height: 37.64px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 237.50px; height: 37.98px;"><img alt="" src="images/image3.png" style="width: 237.50px; height: 37.98px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></h3><p class="c15"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 376.82px; height: 281.08px;"><img alt="" src="images/image14.png" style="width: 376.82px; height: 281.08px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 375.22px; height: 280.92px;"><img alt="" src="images/image26.png" style="width: 375.22px; height: 280.92px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 455.07px; height: 37.97px;"><img alt="" src="images/image9.png" style="width: 455.07px; height: 37.97px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 455.07px; height: 38.00px;"><img alt="" src="images/image25.png" style="width: 455.07px; height: 38.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0 c12"><span class="c6 c4"></span></p><p class="c0"><span class="c6 c4">As we can see, the triangle becomes progressively smoother as the sample rate increases. This is because as the sample rate increases, so too does the number of subpixels that are computed, and a smoother gradient can be calculated. For example, with a sample rate of 4, there are three gradients between red and white possible (1 red 3 white, 2 red 2 white, or 3 red 1 white). However, with a sample rate of 16, we get fifteen possible gradient colors. </span></p><p class="c7"><span class="c4">In addition, as the sample rate increases, we approach the mathematical edge of the triangle, thus allowing for a more accurate sample.</span></p><p class="c0 c12"><span class="c3"></span></p><hr><p class="c0 c12"><span class="c3"></span></p><p class="c0 c12"><span class="c3"></span></p><h3 class="c2" id="h.ruxjvl9umkmm"><span class="c8">Task 3: Transforms</span></h3><p class="c7"><span class="c4">Task 3 involved a simple filling out of matrices to perform each transform. For our custom robot pose, we made it do a handstand. This was done by first flipping the entire robot by 180 degrees. This was done by flipping the torso, as all the other parts were attached to that and would stick with it. Then we rotated one of the upper arms by 90 degrees, and the other arm by 270 degrees to get them pointed downwards. Finally, we added a small translation to reattach the arms to the body.</span></p><h3 class="c2" id="h.izw87kjhth1y"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 410.64px; height: 307.50px;"><img alt="" src="images/image32.png" style="width: 410.64px; height: 307.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></h3><hr><h3 class="c2 c16" id="h.2njyaznd4lht"><span class="c8"></span></h3><h3 class="c2 c16" id="h.oepatyp2jz3k"><span class="c8"></span></h3><h3 class="c2" id="h.wv1q8rkj8nyj"><span class="c8">Task 4: Barycentric coordinates</span></h3><p class="c0"><span class="c6 c4">Barycentric coordinates are a system that allows one to determine if a point is inside a triangle. The coordinates consist of (&#x1d6fc;, &#x1d6fd;, &#x1d6fe;), and if all of them for a point are positive, then the point is inside a triangle. Said point can also be calculated as &#x1d6fc;A + &#x1d6fd;B + &#x1d6fe;C = (x, y), given &#x1d6fc; + &#x1d6fd; + &#x1d6fe; = 1.</span></p><p class="c0"><span class="c4">Barycentric coordinates are also able to linearly interpolate points, where the value of a given coordinate determines how close it is to its corresponding point from the opposite edge. For example, the barycentric coordinates (1, 0, 0) would be equal to point A and be the exact shade of red that is specified at A. However, coordinate (0, 0.5, 0.5) would be directly below point A at the base of the triangle, on line (B, C). This is because it&rsquo;s as far away from A as possible in linear space, but also halfway between both B and C. The color would be the average between blue and green with zero red, which is cyan</span></p><p class="c15"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 403.50px; height: 301.62px;"><img alt="" src="images/image2.png" style="width: 403.50px; height: 301.62px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 26.38px; height: 36.27px;"><img alt="" src="images/image31.png" style="width: 26.38px; height: 36.27px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 26.38px; height: 36.27px;"><img alt="" src="images/image10.png" style="width: 26.38px; height: 36.27px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 26.38px; height: 36.27px;"><img alt="" src="images/image17.png" style="width: 26.38px; height: 36.27px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c7"><span class="c6 c4">Below is an example of a color wheel formed using barycentric coordinates and triangles, with the sample rate set to 1. Despite the default sample rate, we still see a smooth gradient between colors because we&rsquo;re interpolating the colors at each point.</span></p><p class="c15"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 391.50px; height: 293.37px;"><img alt="" src="images/image11.png" style="width: 391.50px; height: 293.37px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c9"><span class="c3"></span></p><hr><p class="c9"><span class="c3"></span></p><p class="c9"><span class="c3"></span></p><h3 class="c2" id="h.e6utccj16a91"><span class="c8">Task 5: &quot;Pixel sampling&quot; for texture mapping</span></h3><p class="c0"><span class="c6 c4">Pixel sampling is a texture mapping technique that maps a pixel within a triangle to its corresponding (u, v) coordinate in the texture space. This allows textures provided by a texture map to be placed into a triangle. To apply the texture, first we need to evaluate the (u, v) coordinate. This was done using barycentric coordinates, in which alpha, beta, and gamma were mapped to u0, u1, u2 respectively (and the same for the v values). The resulting (u, v) coordinate could then be passed into a texture sampling function, either sampling the nearest texel or doing a bilinear interpolation.</span></p><p class="c0"><span class="c6 c4">Sampling the nearest texel was a simple rounding of the (u, v) values, multiplied by the width-1 and height-1 of the texture map. We return the color of the texel.</span></p><p class="c0"><span class="c4">Sampling bilinear interpolation was a little bit trickier. To do this, we had to find the four closest texels to our (u, v) coordinate. This was done with rounding and some subtraction by 1 for the different locations. Once the color of those texels were found, we could then pass them into the lerp() function (with calculated s and t values using the texels&rsquo; centers), finding the weighted average color for the rows, and once again vertically to get the weighted average color between all 4 texels. </span></p><p class="c15"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 380.50px; height: 285.13px;"><img alt="" src="images/image15.png" style="width: 380.50px; height: 285.13px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 382.36px; height: 285.45px;"><img alt="" src="images/image22.png" style="width: 382.36px; height: 285.45px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 301.96px; height: 44.50px;"><img alt="" src="images/image4.png" style="width: 301.96px; height: 44.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 301.96px; height: 44.47px;"><img alt="" src="images/image19.png" style="width: 301.96px; height: 44.47px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c9"><span class="c3"></span></p><p class="c15"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 381.50px; height: 285.37px;"><img alt="" src="images/image13.png" style="width: 381.50px; height: 285.37px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 380.53px; height: 285.14px;"><img alt="" src="images/image30.png" style="width: 380.53px; height: 285.14px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 301.96px; height: 44.47px;"><img alt="" src="images/image8.png" style="width: 301.96px; height: 44.47px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 301.96px; height: 44.47px;"><img alt="" src="images/image24.png" style="width: 301.96px; height: 44.47px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c7 c12"><span class="c6 c4"></span></p><p class="c0"><span class="c6 c4">The above images show the difference between nearest pixel sampling and bilinear pixel sampling. This difference is most pronounced in the top two images, where the longitude lines using nearest pixel sampling are broken, while they are continuous in the bilinear pixel sampling. Even with the sample rate bumped up, while the dashed lines are fixed, it&rsquo;s clear to see that the color doesn&rsquo;t transition as smoothly as the bottom right image which used bilinear pixel sampling.</span></p><p class="c0"><span class="c6 c4">This can be attributed to the fact that the nearest pixel sampling method can sometimes skip over the white longitude line if the blue ocean in the texture map happens to be closer to a given pixel. Bilinear sampling finds the weighted average, so a gradient can be found. Even when sample rate is buffed, the nearest pixel sampling method is more discrete, and so the transition isn&rsquo;t as smooth.</span></p><p class="c0 c12"><span class="c4 c6"></span></p><hr><p class="c0 c12"><span class="c6 c4"></span></p><p class="c0 c12"><span class="c6 c4"></span></p><h3 class="c2" id="h.vky8lg31wi4k"><span class="c8">Task 6: &quot;Level sampling&quot; with mipmaps for texture mapping</span></h3><p class="c0"><span class="c4">The idea of level sampling is, for each sample, to sample from the texture file at the level whose resolution best approximates the screen sampling rate. To implement mipmaps, we first calculated L, which represents the length in pixels of the projection of neighboring screen space samples to texture space. We then were able to use this result to determine the correct texture level D at which to sample from. At a high level, we used the level sampling approach for texture antialiasing, which comes at a small memory cost (~33% more memory). With regards to pixel sampling, bilinear sampling uses 4 texel reads and 3 lerps, while trilinear sampling with mipmaps uses 8 texel reads and 7 lerps. However, the antialiasing improvements of trilinear sampling using mipmaps drastically outweigh its speed costs.</span></p><p class="c13"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 378.50px; height: 283.63px;"><img alt="" src="images/image23.png" style="width: 378.50px; height: 283.63px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span>&nbsp;</span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 379.00px; height: 284.50px;"><img alt="" src="images/image18.png" style="width: 379.00px; height: 284.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 187.00px; height: 38.66px;"><img alt="" src="images/image7.png" style="width: 187.00px; height: 38.66px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 186.50px; height: 38.85px;"><img alt="" src="images/image29.png" style="width: 186.50px; height: 38.85px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c13"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 379.00px; height: 284.00px;"><img alt="" src="images/image6.png" style="width: 379.00px; height: 284.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 381.52px; height: 286.14px;"><img alt="" src="images/image28.png" style="width: 381.52px; height: 286.14px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 186.50px; height: 38.57px;"><img alt="" src="images/image27.png" style="width: 186.50px; height: 38.57px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 186.50px; height: 38.57px;"><img alt="" src="images/image5.png" style="width: 186.50px; height: 38.57px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c6 c4">The two level zeros don&rsquo;t see much of a difference beyond subtle smoothing quality in the bilinear sample, but the difference between a mipmap level of zero and using the nearest level is night and day looking at this banana spot. Finding the nearest level blurs and smooths the image considerably, but it&rsquo;s also notable seeing the difference between nearest pixel sampling and bilinear pixel sampling. The nearest pixel sampling is more noticeably discrete in its color transition, especially towards the right side of the spot. This issue doesn&rsquo;t occur with the bilinear pixel sampling method.</span></p><p class="c0 c12"><span class="c3"></span></p><p class="c0 c12"><span class="c3"></span></p><p class="c0 c12"><span class="c3"></span></p></body></html>