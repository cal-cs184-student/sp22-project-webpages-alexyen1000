<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">@import url('https://themes.googleusercontent.com/fonts/css?kit=-ou4pOz2rBQXdlj5C-P57A');ol{margin:0;padding:0}table td,table th{padding:0}.c5{color:#a64d79;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c2{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c27{padding-top:16pt;padding-bottom:4pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:center}.c4{color:#808080;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:13pt;font-family:"Arial";font-style:normal}.c30{padding-top:14pt;padding-bottom:4pt;line-height:1.15;orphans:2;widows:2;text-align:left;height:14pt}.c34{padding-top:12pt;padding-bottom:2pt;line-height:1.15;orphans:2;widows:2;text-align:center}.c37{padding-top:24pt;padding-bottom:6pt;line-height:1.0;orphans:2;widows:2;text-align:center}.c8{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c3{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:center}.c17{padding-top:14pt;padding-bottom:4pt;line-height:1.15;orphans:2;widows:2;text-align:center}.c10{color:#6aa84f;font-weight:400;text-decoration:none;vertical-align:baseline;font-family:"Times New Roman";font-style:italic}.c14{padding-top:0pt;padding-bottom:10pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c11{color:#808080;font-weight:400;text-decoration:none;vertical-align:baseline;font-family:"Arial";font-style:normal}.c0{padding-top:0pt;padding-bottom:10pt;line-height:1.15;orphans:2;widows:2;text-align:center}.c7{padding-top:12pt;padding-bottom:12pt;line-height:1.15;orphans:2;widows:2;text-align:center}.c38{text-decoration:none;vertical-align:baseline;font-size:23pt;font-family:"Ubuntu";font-style:normal}.c1{font-family:"Times New Roman";font-style:italic;color:#808080;font-weight:400}.c19{text-decoration:none;vertical-align:baseline;font-family:"Arial";font-style:normal}.c23{text-decoration-skip-ink:none;-webkit-text-decoration-skip:none;color:#1155cc;text-decoration:underline}.c12{font-family:"Times New Roman";font-style:italic;color:#6aa84f;font-weight:400}.c18{font-size:13pt;color:#666699;font-weight:700}.c28{background-color:#ffffff;max-width:580.5pt;padding:72pt 18pt 72pt 13.5pt}.c36{color:#666699;font-size:21pt}.c32{color:inherit;text-decoration:inherit}.c35{color:#3c78d8}.c16{color:#6aa84f}.c24{font-weight:700}.c26{color:#000000}.c33{color:#434343}.c13{color:#808080}.c6{height:11pt}.c29{font-family:"Times New Roman"}.c22{color:#674ea7}.c9{font-size:11pt}.c25{font-size:14pt}.c20{font-weight:400}.c31{color:#333333}.c21{color:#45818e}.c15{font-size:12pt}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c28"><h1 class="c37" id="h.fygmoyw3gz35"><span class="c13 c20 c38">CS 184: Sp2022</span></h1><h4 class="c34" id="h.5x1meu3ju9jf"><span class="c11 c9">Alex Yen | Gabriel Khouri-Haddad</span></h4><p class="c3 c6"><span class="c2"></span></p><p class="c3"><span class="c19 c24 c36">MESH EDIT</span></p><h3 class="c17" id="h.ac27z3vsna0v"><span class="c18">Overview</span></h3><p class="c8"><span class="c13">At a high-level, we worked on implementing the components necessary for geometric modeling. We implemented Bezier curves by leveraging the Casteljau algorithm, incorporated area-weighted vertex normals to provide shading and smoother surfaces, and implemented the half-edge data structure which enables us to efficiently and correctly perform edge flip, edge split, and loop subdivision operations. This project gave us the low-level understanding and intuition for how meshes are created, how they can be manipulated, and how they can precisely model different geometries. It was particularly interesting to learn about the different tradeoffs that come from modeling meshes with the half-edge data structure.</span></p><hr><p class="c7 c6"><span class="c11 c9"></span></p><h3 class="c17" id="h.28gc17keqxt8"><span class="c19 c18">Task 1: Bezier Curves and Surfaces</span></h3><p class="c3"><span class="c13">To find the Bezier curve of a set of points requires the usage of De Casteljau&rsquo;s algorithm. This is a recursive method to evaluate a set of </span><span class="c1">n</span><span class="c13">&nbsp;control points by taking the linear interpolation between each pair of points in sequence, which finds the next level of </span><span class="c1">n - 1</span><span class="c11 c9">&nbsp;control points. Continuing the recursion until there&rsquo;s only a single control point left, which becomes a point on the bezier curve. The other points are found by changing what the linear interpolation is weighted by, and so the curve is found by calculating the continuous set of final control points.</span></p><p class="c3 c6"><span class="c11 c9"></span></p><p class="c3"><span class="c11 c9">In our implementation, we simply needed to fill out the linear interpolation of a given step, provided a set of control points. This is done by iterating through all the control points, linearly interpolating it with the next control point, and appending the resulting point into an output vector containing the next level of control points. We also stop the iteration before the final control point, as there&rsquo;s no next control point with which to linearly interpolate it.</span></p><p class="c3 c6"><span class="c11 c9"></span></p><p class="c3"><span class="c13">Below shows the process of finding the Bezier curve given 6 points, which requires five linear interpolations:</span></p><p class="c7"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 334.37px; height: 231.42px;"><img alt="" src="images/image8.png" style="width: 334.37px; height: 231.42px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c7"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 355.99px; height: 248.50px;"><img alt="" src="images/image19.png" style="width: 355.99px; height: 248.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c7"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 354.50px; height: 246.18px;"><img alt="" src="images/image20.png" style="width: 354.50px; height: 246.18px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c7"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 354.71px; height: 246.22px;"><img alt="" src="images/image16.png" style="width: 354.71px; height: 246.22px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c7"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 356.59px; height: 248.50px;"><img alt="" src="images/image11.png" style="width: 356.59px; height: 248.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c7"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 358.72px; height: 249.14px;"><img alt="" src="images/image28.png" style="width: 358.72px; height: 249.14px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c7"><span class="c11 c9">And here is the curve with the points at a different position:</span></p><p class="c7"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 357.98px; height: 249.78px;"><img alt="" src="images/image25.png" style="width: 357.98px; height: 249.78px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><hr></p><h3 class="c17" id="h.z35prlusp4oe"><span class="c19 c18">Task 2: Bezier Surfaces with Separable 1D de Casteljau</span></h3><h3 class="c17" id="h.oww9de451g49"><span class="c13 c9">A Bezier surface is simply the extension of a Bezier curve in the 3rd dimension. We&rsquo;re still given a set of control points, but this time they&rsquo;re ordered in a </span><span class="c1 c9">n </span><span class="c13 c9 c20 c29">x</span><span class="c1 c9">&nbsp;n</span><span class="c13 c9">&nbsp;matrix. Essentially, we have an array of Bezier curves. By finding the final control point for all these Bezier curves, let&rsquo;s call them the u-direction curves, we now have a new set of control points that allow us to find the final point in the v-direction. This works because the points are all weighted by the same </span><span class="c1 c9">u</span><span class="c11 c9">&nbsp;value, which puts the resulting v-direction curve as perpendicular to the array of u-direction curves</span></h3><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 340.48px; height: 263.00px;"><img alt="" src="images/image26.png" style="width: 340.48px; height: 263.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><h3 class="c17" id="h.pvowr6cv6miz"><span class="c13 c9">Overall, this allows us to find a final control point for the entire surface, </span><span class="c1 c9">(u, v)</span><span class="c13 c9">, which is weighted according to the values of </span><span class="c1 c9">u</span><span class="c13 c9">&nbsp;and </span><span class="c1 c9">v</span><span class="c11 c9">&nbsp;when doing linear interpolation.</span></h3><p class="c8 c6"><span class="c2"></span></p><p class="c3"><span class="c11 c9">In order to implement this, we first had to fill out evaluateStep(). This was a simple copypaste of the previous part, though now we used Vector3Ds instead of Vector2Ds, working in a 3D space. As a reminder, this returns the next level of control points.</span></p><p class="c3 c6"><span class="c11 c9"></span></p><p class="c3"><span class="c11 c9">The next part was to implement evaluate1D(), which evaluated the final point given a one-dimensional array of control points. This was a simple recursive function, which would calculate the output of evaluateStep() and then call evaluate1D() again using said output. The base case was when the given set of control points only consisted of a single point, in which we&rsquo;d return that point. This was the end of the recursion, and so it was the point that laid on the Bezier surface at the provided weight value.</span></p><p class="c3 c6"><span class="c11 c9"></span></p><p class="c3"><span class="c13">The final function to complete was evaluate(), which calculated the final point given </span><span class="c1">(u, v)</span><span class="c13">. First, we needed to calculate the points in the u-direction. We used a for loop to get each row from the 2D vector of control points, and passed those into evaluate1D() weighted by </span><span class="c1">u</span><span class="c13">. The result of which we append to a new 1D vector which contained all of the control points in the u-axis. Given this vector, we pass it through evaluate1D() one more time, weighted by </span><span class="c1">v</span><span class="c13">, which gives us the final point </span><span class="c1">(u, v)</span><span class="c11 c9">. </span></p><p class="c3 c6"><span class="c11 c9"></span></p><p class="c3"><span class="c13">Below is a teapot rendered using bezier surfaces:</span></p><p class="c3 c6"><span class="c2"></span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 378.50px; height: 263.19px;"><img alt="" src="images/image33.png" style="width: 378.50px; height: 263.19px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><hr><p class="c6 c14"><span class="c2"></span></p><h3 class="c17" id="h.ruxjvl9umkmm"><span class="c19 c18">Task 3: Area-Weighted Vertex Normals</span></h3><p class="c3"><span class="c11 c9">In order to compute vertex normals at each vertex, we iterated through every triangle incident to a vertex, and summed their areas weighted by their normals. At the end, we normalized this sum to get the normalized area-weighted vertex normals.</span></p><h3 class="c27" id="h.aui5lpkrrj9d"><span class="c13 c15">Before Vertex Normals:</span></h3><h3 class="c17" id="h.o4a6pvgcewdd"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 512.00px; height: 267.40px;"><img alt="" src="images/image38.png" style="width: 512.00px; height: 267.40px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></h3><h3 class="c27" id="h.ur9paxfycfdr"><span class="c11 c15">After Vertex Normals:</span></h3><h3 class="c17" id="h.y0cuyzdw6yx9"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 508.92px; height: 252.15px;"><img alt="" src="images/image24.png" style="width: 508.92px; height: 252.15px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></h3><hr><h3 class="c30" id="h.2njyaznd4lht"><span class="c19 c18"></span></h3><h3 class="c17" id="h.wv1q8rkj8nyj"><span class="c19 c18">Task 4: Edge Flip</span></h3><p class="c3"><span class="c11 c9">To implement the edge flip operation, we followed the suggestion in the spec and wrote down all of the half edges, edges, and vertices of the mesh before and after the edge flip. This helped us visualize and understand all of the pointer changes that were being performed in the edge flip. Once we had all the pointer changes laid out, we were able to systematically implement the pointer modifications in the code by leveraging the setNeighbors operation provided to us. Thankfully, we did not have any major bugs/debugging journey for this function.</span></p><p class="c3 c6"><span class="c11 c9"></span></p><p class="c3"><span class="c11 c15">Before edge flip:</span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 610.50px; height: 359.67px;"><img alt="" src="images/image31.png" style="width: 610.50px; height: 359.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c3"><span class="c13 c15">After edge flip:</span></p><p class="c3 c6"><span class="c11 c9"></span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 583.49px; height: 341.50px;"><img alt="" src="images/image18.png" style="width: 583.49px; height: 341.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c3 c6"><span class="c11 c9"></span></p><p class="c3"><span class="c13 c15">Before edge flip:</span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 589.50px; height: 352.72px;"><img alt="" src="images/image23.png" style="width: 589.50px; height: 352.72px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c3"><span class="c11 c15">After edge flip:</span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 579.34px; height: 333.50px;"><img alt="" src="images/image37.png" style="width: 579.34px; height: 333.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c8 c6"><span class="c2"></span></p><hr><p class="c3 c6"><span class="c2"></span></p><h3 class="c17" id="h.e6utccj16a91"><span class="c19 c18">Task 5: Edge Split</span></h3><p class="c3"><span class="c11 c9">To implement the edge split operation, we followed the same approach as edge flipping. First, we wrote down all of the halfedges, edges, vertices, and faces before and after the edge split operation. Using this, we were able to determine which halfedges, edges, vertices, and faces needed to be created, and how to manage each element&rsquo;s pointers to ensure the correctness of the edge splitting operation. Once we had laid this out, we were able to implement the edge split functionality in code. Unfortunately, we did run into quite a few bugs throughout this journey. We were able to successfully debug by combing over each line and making sure we were accessing the correct elements via the next() and twin() function calls. Many of our bugs were solved this way. </span></p><p class="c8 c6"><span class="c2"></span></p><p class="c3"><span class="c13 c15">Before edge split:</span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 552.95px; height: 293.97px;"><img alt="" src="images/image9.png" style="width: 552.95px; height: 293.97px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c8 c6"><span class="c2"></span></p><p class="c3 c6"><span class="c11 c15"></span></p><p class="c3"><span class="c13 c15">After edge split:</span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 657.13px; height: 329.50px;"><img alt="" src="images/image34.png" style="width: 657.13px; height: 329.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c3 c6"><span class="c11 c9"></span></p><p class="c3"><span class="c13 c15">Before edge split:</span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 489.37px; height: 344.34px;"><img alt="" src="images/image32.png" style="width: 489.37px; height: 344.34px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c3 c6"><span class="c11 c15"></span></p><p class="c3"><span class="c11 c15">After edge split:</span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 465.50px; height: 379.88px;"><img alt="" src="images/image17.png" style="width: 465.50px; height: 379.88px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c14 c6"><span class="c11 c9"></span></p><p class="c0"><span class="c11 c9">Before the combination of edge flip/edge split:</span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 551.50px; height: 328.48px;"><img alt="" src="images/image12.png" style="width: 551.50px; height: 328.48px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c11 c9">After combination of edge flip/edge split:</span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 554.50px; height: 346.03px;"><img alt="" src="images/image21.png" style="width: 554.50px; height: 346.03px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><hr><p class="c0 c6"><span class="c11 c9"></span></p><h3 class="c17" id="h.vky8lg31wi4k"><span class="c18 c19">Task 6: Loop Subdivision for Mesh Upsampling</span></h3><p class="c3"><span class="c11 c9">To do loop subdivision, we implemented these 5 steps:</span></p><p class="c3 c6"><span class="c11 c9"></span></p><p class="c3"><span class="c19 c16 c9 c20">We compute the new positions of all of the vertices in the mesh and temporarily store them in Vertex::newPosition to update later on. We do this by iterating through all the vertices in the mesh (also confirming them to be part of the original mesh by flagging isNew = false), and then following the loop subdivision rule; that is the the new position:</span></p><p class="c3 c6"><span class="c19 c16 c9 c20"></span></p><p class="c3"><span class="c16">&nbsp;</span><img src="images/image1.png"></p><p class="c3"><span class="c16">Where </span><img src="images/image2.png"><span class="c16">, </span><img src="images/image3.png"><span class="c16">&nbsp;if </span><img src="images/image4.png"><span class="c16">, else </span><img src="images/image5.png"></p><p class="c3"><span class="c16">And </span><span class="c12">original_neighbor_position_sum</span><span class="c16">&nbsp;is the sum of all the positions of the vertices adjacent to </span><span class="c9 c10">v</span></p><p class="c3 c6"><span class="c11 c9"></span></p><p class="c3"><span class="c19 c9 c20 c21">The next step is to compute the positions of all the newly inserted vertices and store them in Edge::newPosition to use later on, as we haven&rsquo;t actually created the vertices yet. All the new vertices will be created based on the existing edges, so this works out. This is done by iterating through all the edges in the mesh (also confirming them to part of the original mesh by flagging isNew = false). We then find the four original vertices that will &ldquo;surround&rdquo; the new vertex at this edge, A, B, C, D, and then calculate the new position:</span></p><p class="c3"><img src="images/image6.png"></p><p class="c3"><span class="c19 c9 c20 c21">A, B, C, D were found following this diagram:</span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 188.00px; height: 251.00px;"><img alt="" src="images/image30.png" style="width: 774.00px; height: 251.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c3"><span class="c19 c9 c20 c35">Next, we need to split every edge in the original mesh (excluding boundary edges). This is done by iterating through all the edges and splitting them, but only if its vertex and its twin&rsquo;s vertex are part of the original mesh as edges that were created from splitting are flagged as new edges. This prevents an infinite loop to occur in which we never reach the end because we keep splitting edges we&rsquo;ve already split. We also set the newPosition of the newly generated vertex to the stored Edge::newPosition that we calculated previously, but we don&rsquo;t change the vertex&rsquo;s actual position yet.</span></p><p class="c3 c6"><span class="c11 c9"></span></p><p class="c3"><span class="c19 c9 c20 c22">Now we move on to flipping any edges that have an old vertex and a new vertex. This was done by iterating all the edges and flipping any new edge that passed an XOR check</span></p><p class="c3 c6"><span class="c19 c22 c9 c20"></span></p><p class="c3"><span class="c5">Finally, we update all the positions of the vertex using the positions stored in Vertex::newPosition</span></p><p class="c3 c6"><span class="c5"></span></p><p class="c3"><span class="c11 c9">We did run into a few hiccups, first by trying to do multiple steps within one while loop. This introduced issues in which edges would get altered before they were supposed to, which disturbed the mesh. Another thing was not realizing we could iterate through the vertices, so we were iterating through the edges even though we weren&rsquo;t supposed to (this obviously created some wrong values as the newPositions were getting overwritten.</span></p><p class="c3 c6"><span class="c11 c9"></span></p><p class="c3"><span class="c13">The result of that can be seen below, where this ring is repeatedly upscaled, becoming smoother. </span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 265.50px; height: 184.96px;"><img alt="" src="images/image36.png" style="width: 265.50px; height: 184.96px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 266.22px; height: 184.50px;"><img alt="" src="images/image39.png" style="width: 266.22px; height: 184.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 266.50px; height: 185.71px;"><img alt="" src="images/image14.png" style="width: 266.50px; height: 185.71px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 265.24px; height: 185.50px;"><img alt="" src="images/image7.png" style="width: 265.24px; height: 185.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c3"><span class="c11 c9">An interesting to note is how sharp edges and corners become rounded, and the mesh &ldquo;loses mass&rdquo; as we upscale. This is most noticeable in the early upscaling steps</span></p><p class="c3 c6"><span class="c11 c9"></span></p><p class="c3"><span class="c11 c9">We can at least combat the rounding effect by preprocessing the mesh and splitting a face of this cube many times before doing any upscaling:</span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 440.50px; height: 306.11px;"><img alt="" src="images/image27.png" style="width: 440.50px; height: 306.11px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c11 c9">As we can see, after upscaling three times, the face that was pre-split remains flat instead of rounded like the other five faces:</span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 440.02px; height: 306.50px;"><img alt="" src="images/image29.png" style="width: 440.02px; height: 306.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c3 c6"><span class="c11 c9"></span></p><p class="c3"><span class="c11 c9">Speaking of cubes, it doesn&rsquo;t subdivide symmetrically in its default configuration. Here we can see a before and after picture of the cube after 3 levels of upscaling. It&rsquo;s clearly more rounded on two sides, and pointed on the other two</span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 304.54px; height: 212.47px;"><img alt="" src="images/image13.png" style="width: 304.54px; height: 212.47px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 304.50px; height: 211.41px;"><img alt="" src="images/image22.png" style="width: 304.50px; height: 211.41px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c11 c9">To fix this, we simply need to preprocess the cube like before. This was a simple splitting of each face such that the triangles formed a cross. The following images go through the upscaling process.</span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 303.50px; height: 210.76px;"><img alt="" src="images/image15.png" style="width: 303.50px; height: 210.76px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 304.50px; height: 212.58px;"><img alt="" src="images/image40.png" style="width: 304.50px; height: 212.58px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 304.64px; height: 212.56px;"><img alt="" src="images/image35.png" style="width: 304.64px; height: 212.56px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c11 c9">Looking at the cube at the same upscale level dead on shows that it&rsquo;s no longer asymmetric:</span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 354.50px; height: 247.33px;"><img alt="" src="images/image10.png" style="width: 354.50px; height: 247.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c11 c9">This fix works because after the pre-processing, each edge of the cube contained an isosceles triangle instead of a right triangle, meaning when it split, it was no longer done so unevenly</span></p><p class="c0 c6"><span class="c2"></span></p><p class="c0"><span class="c23"><a class="c32" href="https://www.google.com/url?q=https://github.com/cal-cs184-student/sp22-project-webpages-alexyen1000/blob/master/proj1/index.html&amp;sa=D&amp;source=editors&amp;ust=1646203121880175&amp;usg=AOvVaw1BL2viBRrCMNpXbO9vKsp1">https://github.com/cal-cs184-student/sp22-project-webpages-alexyen1000/blob/master/proj2/index.html</a></span></p><p class="c0 c6"><span class="c2"></span></p><p class="c0 c6"><span class="c2"></span></p><div><p class="c8 c6"><span class="c2"></span></p><p class="c6 c8"><span class="c2"></span></p></div></body></html>